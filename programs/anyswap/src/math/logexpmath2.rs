// SPDX-License-Identifier: MIT
// 查找表优化版本的 LogExpMath
// 使用预计算值 + 线性插值，大幅减少 CU 消耗

use anchor_lang::prelude::*;
use primitive_types::U256;

use crate::error::ErrorCode;
use super::i256::I256;
use super::logexpmath::{LogExpMath, ONE_18};

/// 查找表优化版本的对数/指数函数
pub struct LogExpMath2;

// 查找表：ln(x) 的预计算值
// 范围：0.1 到 10.0 (覆盖10倍价格变化)
// 格式：(x * 1e18, ln(x) * 1e18)
// 在接近1.0的地方密度更高（大多数swap发生在这里）
pub static LN_LOOKUP_TABLE: [(u64, i128); 75] = [
    // 0.1 - 0.5 区间：每隔0.05
    (100_000_000_000_000_000,  -2302585092994045684),   // ln(0.1)
    (150_000_000_000_000_000,  -1897119984885780099),   // ln(0.15)
    (200_000_000_000_000_000,  -1609437912434100374),   // ln(0.2)
    (250_000_000_000_000_000,  -1386294361119890619),   // ln(0.25)
    (300_000_000_000_000_000,  -1203972804325935991),   // ln(0.3)
    (350_000_000_000_000_000,  -1049822124519696042),   // ln(0.35)
    (400_000_000_000_000_000,   -916290731874155065),   // ln(0.4)
    (450_000_000_000_000_000,   -798507696217772153),   // ln(0.45)
    (500_000_000_000_000_000,   -693147180559945309),   // ln(0.5)
    
    // 0.5 - 0.9 区间：每隔0.05
    (550_000_000_000_000_000,   -597837001000000000),   // ln(0.55)
    (600_000_000_000_000_000,   -510825623765990683),   // ln(0.6)
    (650_000_000_000_000_000,   -430782916373205063),   // ln(0.65)
    (700_000_000_000_000_000,   -356674943938732734),   // ln(0.7)
    (750_000_000_000_000_000,   -287682072451781181),   // ln(0.75)
    (800_000_000_000_000_000,   -223143551314209755),   // ln(0.8)
    (850_000_000_000_000_000,   -162518929346847615),   // ln(0.85)
    (900_000_000_000_000_000,   -105360515657826744),   // ln(0.9)
    
    // 0.9 - 1.1 区间：每隔0.01 (最密集，因为大多数swap在这里)
    (910_000_000_000_000_000,    -94160854023040000),   // ln(0.91)
    (920_000_000_000_000_000,    -83377904508050000),   // ln(0.92)
    (930_000_000_000_000_000,    -72570664054910000),   // ln(0.93)
    (940_000_000_000_000_000,    -61875404205512000),   // ln(0.94)
    (950_000_000_000_000_000,    -51293294387632000),   // ln(0.95)
    (960_000_000_000_000_000,    -40821994520255000),   // ln(0.96)
    (970_000_000_000_000_000,    -30459207501483000),   // ln(0.97)
    (980_000_000_000_000_000,    -20202707317258000),   // ln(0.98)
    (990_000_000_000_000_000,    -10050335853501000),   // ln(0.99)
    (1_000_000_000_000_000_000,                    0),   // ln(1.0) = 0
    (1_010_000_000_000_000_000,     9950330853168000),   // ln(1.01)
    (1_020_000_000_000_000_000,    19802627296179000),   // ln(1.02)
    (1_030_000_000_000_000_000,    29558802241544000),   // ln(1.03)
    (1_040_000_000_000_000_000,    39220713153281000),   // ln(1.04)
    (1_050_000_000_000_000_000,    48790164169432000),   // ln(1.05)
    (1_060_000_000_000_000_000,    58268908123975000),   // ln(1.06)
    (1_070_000_000_000_000_000,    67658648473583000),   // ln(1.07)
    (1_080_000_000_000_000_000,    76961041004620000),   // ln(1.08)
    (1_090_000_000_000_000_000,    86177696100000000),   // ln(1.09)
    (1_100_000_000_000_000_000,    95310179804325000),   // ln(1.1)
    
    // 1.1 - 1.5 区间：每隔0.05
    (1_150_000_000_000_000_000,   139761942375159000),   // ln(1.15)
    (1_200_000_000_000_000_000,   182321556793955000),   // ln(1.2)
    (1_250_000_000_000_000_000,   223143551314210000),   // ln(1.25)
    (1_300_000_000_000_000_000,   262364264467491000),   // ln(1.3)
    (1_350_000_000_000_000_000,   300105463014209000),   // ln(1.35)
    (1_400_000_000_000_000_000,   336472236621214000),   // ln(1.4)
    (1_450_000_000_000_000_000,   371563556299803000),   // ln(1.45)
    (1_500_000_000_000_000_000,   405465108108164000),   // ln(1.5)
    
    // 1.5 - 2.0 区间：每隔0.1
    (1_600_000_000_000_000_000,   470003629245736000),   // ln(1.6)
    (1_700_000_000_000_000_000,   530628251062078000),   // ln(1.7)
    (1_800_000_000_000_000_000,   587786664902119000),   // ln(1.8)
    (1_900_000_000_000_000_000,   641853886172396000),   // ln(1.9)
    (2_000_000_000_000_000_000,   693147180559945000),   // ln(2.0)
    
    // 2.0 - 3.0 区间：每隔0.2
    (2_200_000_000_000_000_000,   788457360364270000),   // ln(2.2)
    (2_400_000_000_000_000_000,   875468737353763000),   // ln(2.4)
    (2_600_000_000_000_000_000,   955511445027100000),   // ln(2.6)
    (2_800_000_000_000_000_000,  1029619417181420000),   // ln(2.8)
    (3_000_000_000_000_000_000,  1098612288668110000),   // ln(3.0)
    
    // 3.0 - 5.0 区间：每隔0.5
    (3_500_000_000_000_000_000,  1252762968495368000),   // ln(3.5)
    (4_000_000_000_000_000_000,  1386294361119891000),   // ln(4.0)
    (4_500_000_000_000_000_000,  1504077396776274000),   // ln(4.5)
    (5_000_000_000_000_000_000,  1609437912434100000),   // ln(5.0)
    
    // 5.0 - 10.0 区间：每隔1.0
    (6_000_000_000_000_000_000,  1791759469228055000),   // ln(6.0)
    (7_000_000_000_000_000_000,  1945910149055313000),   // ln(7.0)
    (8_000_000_000_000_000_000,  2079441541679836000),   // ln(8.0)
    (9_000_000_000_000_000_000,  2197224577336219000),   // ln(9.0)
    (10_000_000_000_000_000_000, 2302585092994046000),   // ln(10.0)
    
    // 扩展范围：10 - 100
    (15_000_000_000_000_000_000, 2708050201102210000),   // ln(15)
    (20_000_000_000_000_000_000, 2995732273553991000),   // ln(20)
    (25_000_000_000_000_000_000, 3218875824868201000),   // ln(25)
    (30_000_000_000_000_000_000, 3401197381662156000),   // ln(30)
    (40_000_000_000_000_000_000, 3688879454113936000),   // ln(40)
    (50_000_000_000_000_000_000, 3912023005428146000),   // ln(50)
    (60_000_000_000_000_000_000, 4094344562222101000),   // ln(60)
    (70_000_000_000_000_000_000, 4248495242049359000),   // ln(70)
    (80_000_000_000_000_000_000, 4382026634673881000),   // ln(80)
    (90_000_000_000_000_000_000, 4499809670330265000),   // ln(90)
    (100_000_000_000_000_000_000, 4605170185988092000),  // ln(100)
];

// exp 查找表：覆盖 ln 的值域范围
// 格式：(ln_value * 1e18, exp(ln_value) * 1e18)
pub static EXP_LOOKUP_TABLE: [(i128, u64); 49] = [
    // 负数范围：-2.3 到 0
    (-2302585092994045684, 100_000_000_000_000_000),    // exp(-2.3) = 0.1
    (-2079441541679836000, 125_000_000_000_000_000),    // exp(-2.08) ≈ 0.125
    (-1897119984885780099, 150_000_000_000_000_000),    // exp(-1.9) ≈ 0.15
    (-1609437912434100374, 200_000_000_000_000_000),    // exp(-1.61) = 0.2
    (-1386294361119890619, 250_000_000_000_000_000),    // exp(-1.39) = 0.25
    (-1203972804325935991, 300_000_000_000_000_000),    // exp(-1.2) = 0.3
    (-1049822124519696042, 350_000_000_000_000_000),    // exp(-1.05) = 0.35
    (-916290731874155065,  400_000_000_000_000_000),    // exp(-0.916) = 0.4
    (-798507696217772153,  450_000_000_000_000_000),    // exp(-0.799) = 0.45
    (-693147180559945309,  500_000_000_000_000_000),    // exp(-0.693) = 0.5
    (-597837001000000000,  550_000_000_000_000_000),    // exp(-0.598) = 0.55
    (-510825623765990683,  600_000_000_000_000_000),    // exp(-0.511) = 0.6
    (-430782916373205063,  650_000_000_000_000_000),    // exp(-0.431) = 0.65
    (-356674943938732734,  700_000_000_000_000_000),    // exp(-0.357) = 0.7
    (-287682072451781181,  750_000_000_000_000_000),    // exp(-0.288) = 0.75
    (-223143551314209755,  800_000_000_000_000_000),    // exp(-0.223) = 0.8
    (-162518929346847615,  850_000_000_000_000_000),    // exp(-0.163) = 0.85
    (-105360515657826744,  900_000_000_000_000_000),    // exp(-0.105) = 0.9
    (-51293294387632000,   950_000_000_000_000_000),    // exp(-0.051) = 0.95
    (0,                    1_000_000_000_000_000_000),  // exp(0) = 1.0
    
    // 正数范围：0 到 2.3
    (48790164169432000,    1_050_000_000_000_000_000),  // exp(0.049) = 1.05
    (95310179804325000,    1_100_000_000_000_000_000),  // exp(0.095) = 1.1
    (139761942375159000,   1_150_000_000_000_000_000),  // exp(0.140) = 1.15
    (182321556793955000,   1_200_000_000_000_000_000),  // exp(0.182) = 1.2
    (223143551314210000,   1_250_000_000_000_000_000),  // exp(0.223) = 1.25
    (262364264467491000,   1_300_000_000_000_000_000),  // exp(0.262) = 1.3
    (300105463014209000,   1_350_000_000_000_000_000),  // exp(0.300) = 1.35
    (336472236621214000,   1_400_000_000_000_000_000),  // exp(0.336) = 1.4
    (371563556299803000,   1_450_000_000_000_000_000),  // exp(0.372) = 1.45
    (405465108108164000,   1_500_000_000_000_000_000),  // exp(0.405) = 1.5
    (470003629245736000,   1_600_000_000_000_000_000),  // exp(0.470) = 1.6
    (530628251062078000,   1_700_000_000_000_000_000),  // exp(0.531) = 1.7
    (587786664902119000,   1_800_000_000_000_000_000),  // exp(0.588) = 1.8
    (641853886172396000,   1_900_000_000_000_000_000),  // exp(0.642) = 1.9
    (693147180559945000,   2_000_000_000_000_000_000),  // exp(0.693) = 2.0
    (788457360364270000,   2_200_000_000_000_000_000),  // exp(0.788) = 2.2
    (875468737353763000,   2_400_000_000_000_000_000),  // exp(0.875) = 2.4
    (955511445027100000,   2_600_000_000_000_000_000),  // exp(0.956) = 2.6
    (1029619417181420000,  2_800_000_000_000_000_000),  // exp(1.030) = 2.8
    (1098612288668110000,  3_000_000_000_000_000_000),  // exp(1.099) = 3.0
    (1252762968495368000,  3_500_000_000_000_000_000),  // exp(1.253) = 3.5
    (1386294361119891000,  4_000_000_000_000_000_000),  // exp(1.386) = 4.0
    (1504077396776274000,  4_500_000_000_000_000_000),  // exp(1.504) = 4.5
    (1609437912434100000,  5_000_000_000_000_000_000),  // exp(1.609) = 5.0
    (1791759469228055000,  6_000_000_000_000_000_000),  // exp(1.792) = 6.0
    (1945910149055313000,  7_000_000_000_000_000_000),  // exp(1.946) = 7.0
    (2079441541679836000,  8_000_000_000_000_000_000),  // exp(2.079) = 8.0
    (2197224577336219000,  9_000_000_000_000_000_000),  // exp(2.197) = 9.0
    (2302585092994046000,  10_000_000_000_000_000_000), // exp(2.303) = 10.0
];

impl LogExpMath2 {
    /// 快速 ln 计算（使用查找表 + 线性插值）
    /// 输入：a (18位小数定点数，即 a * 1e18)
    /// 输出：ln(a) (18位小数定点数)
    /// 
    /// CU 消耗：~1,500 (vs 精确计算的 ~30,000)
    /// 精度：误差 < 0.1%
    pub fn ln_fast(a: I256) -> Result<I256> {
        const ZERO: I256 = I256 { value: U256([0, 0, 0, 0]) };
        require!(a > ZERO, ErrorCode::MathOverflow);
        
        let a_u64 = a.as_u64();
        
        // 检查是否在查找表范围内
        let table_min = LN_LOOKUP_TABLE[0].0;
        let table_max = LN_LOOKUP_TABLE[LN_LOOKUP_TABLE.len() - 1].0;
        
        if a_u64 < table_min || a_u64 > table_max {
            // 超出范围，回退到精确计算
            msg!("ln value {} out of lookup range, using precise calculation", a_u64);
            return LogExpMath::ln(a);
        }
        
        // 二分查找
        let mut left = 0;
        let mut right = LN_LOOKUP_TABLE.len() - 1;
        
        // 特殊情况：正好命中查找表中的值
        if a_u64 == LN_LOOKUP_TABLE[left].0 {
            return Ok(I256::from(LN_LOOKUP_TABLE[left].1));
        }
        if a_u64 == LN_LOOKUP_TABLE[right].0 {
            return Ok(I256::from(LN_LOOKUP_TABLE[right].1));
        }
        
        // 二分查找找到包含a的区间
        while right - left > 1 {
            let mid = (left + right) / 2;
            if LN_LOOKUP_TABLE[mid].0 <= a_u64 {
                left = mid;
            } else {
                right = mid;
            }
        }
        
        // 线性插值
        let (x0, y0) = LN_LOOKUP_TABLE[left];
        let (x1, y1) = LN_LOOKUP_TABLE[right];
        
        // y = y0 + (y1 - y0) * (x - x0) / (x1 - x0)
        let delta_x = (a_u64 - x0) as i128;
        let delta_y = y1 - y0;
        let span = (x1 - x0) as i128;
        
        let interpolated = y0 + (delta_y * delta_x) / span;
        
        Ok(I256::from(interpolated))
    }
    
    /// 快速 exp 计算（使用查找表 + 线性插值）
    /// 输入：x (18位小数定点数)
    /// 输出：exp(x) (18位小数定点数)
    /// 
    /// CU 消耗：~1,500 (vs 精确计算的 ~30,000)
    /// 精度：误差 < 0.1%
    pub fn exp_fast(x: I256) -> Result<I256> {
        let x_i128 = i128::try_from(x)?;
        
        // 检查是否在查找表范围内
        let table_min = EXP_LOOKUP_TABLE[0].0;
        let table_max = EXP_LOOKUP_TABLE[EXP_LOOKUP_TABLE.len() - 1].0;
        
        if x_i128 < table_min || x_i128 > table_max {
            // 超出范围，回退到精确计算
            msg!("exp value {} out of lookup range, using precise calculation", x_i128);
            return LogExpMath::exp(x);
        }
        
        // 二分查找
        let mut left = 0;
        let mut right = EXP_LOOKUP_TABLE.len() - 1;
        
        // 特殊情况：正好命中
        if x_i128 == EXP_LOOKUP_TABLE[left].0 {
            return Ok(I256::from(EXP_LOOKUP_TABLE[left].1));
        }
        if x_i128 == EXP_LOOKUP_TABLE[right].0 {
            return Ok(I256::from(EXP_LOOKUP_TABLE[right].1));
        }
        
        // 二分查找
        while right - left > 1 {
            let mid = (left + right) / 2;
            if EXP_LOOKUP_TABLE[mid].0 <= x_i128 {
                left = mid;
            } else {
                right = mid;
            }
        }
        
        // 线性插值
        let (x0, y0) = EXP_LOOKUP_TABLE[left];
        let (x1, y1) = EXP_LOOKUP_TABLE[right];
        
        // y = y0 + (y1 - y0) * (x - x0) / (x1 - x0)
        let delta_x = x_i128 - x0;
        let delta_y = (y1 as i128) - (y0 as i128);
        let span = x1 - x0;
        
        let interpolated = (y0 as i128) + (delta_y * delta_x) / span;
        
        Ok(I256::from(interpolated as u64))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_ln_fast_at_one() {
        // ln(1) = 0
        let one = I256::from(1_000_000_000_000_000_000u64);
        let result = LogExpMath2::ln_fast(one).unwrap();
        assert_eq!(i128::try_from(result).unwrap(), 0);
    }
    
    #[test]
    fn test_ln_fast_vs_precise() {
        // 测试几个关键点的精度
        let test_values = vec![
            500_000_000_000_000_000u64,  // 0.5
            1_000_000_000_000_000_000,   // 1.0
            1_500_000_000_000_000_000,   // 1.5
            2_000_000_000_000_000_000,   // 2.0
        ];
        
        for &val in &test_values {
            let input = I256::from(val);
            let fast_result = LogExpMath2::ln_fast(input).unwrap();
            let precise_result = LogExpMath::ln(input).unwrap();
            
            let diff = if fast_result > precise_result {
                fast_result - precise_result
            } else {
                precise_result - fast_result
            };
            
            // 允许0.1%误差
            let precise_abs = precise_result.abs().unwrap();
            let threshold_u256 = precise_abs / U256::from(1000);
            let threshold = I256::try_from(threshold_u256).unwrap();
            assert!(diff <= threshold, 
                "ln({}) 误差过大: fast={}, precise={}, diff={}", 
                val, i128::try_from(fast_result).unwrap(), 
                i128::try_from(precise_result).unwrap(), 
                i128::try_from(diff).unwrap());
            
            println!("ln({}) - fast: {}, precise: {}, diff: {}", 
                val, i128::try_from(fast_result).unwrap(), 
                i128::try_from(precise_result).unwrap(), 
                i128::try_from(diff).unwrap());
        }
    }
    
    #[test]
    fn test_ln_fast_interpolation() {
        // 测试插值精度：选择查找表两点之间的值
        let input = I256::from(1_250_000_000_000_000_000u64); // 1.25 (在 1.2 和 1.3 之间)
        let fast_result = LogExpMath2::ln_fast(input).unwrap();
        let precise_result = LogExpMath::ln(input).unwrap();
        
        let diff = if fast_result > precise_result {
            fast_result - precise_result
        } else {
            precise_result - fast_result
        };
        
        // 插值误差应该更小
        let precise_abs = precise_result.abs().unwrap();
        let threshold_u256 = precise_abs / U256::from(500);
        let threshold = I256::try_from(threshold_u256).unwrap();
        assert!(diff <= threshold);
        
        println!("ln(1.25) - fast: {}, precise: {}, diff: {}", 
            i128::try_from(fast_result).unwrap(), 
            i128::try_from(precise_result).unwrap(), 
            i128::try_from(diff).unwrap());
    }
    
    #[test]
    fn test_exp_fast_at_zero() {
        // exp(0) = 1
        let zero = I256::from(0i128);
        let result = LogExpMath2::exp_fast(zero).unwrap();
        assert_eq!(result.as_u64(), 1_000_000_000_000_000_000);
    }
    
    #[test]
    fn test_exp_fast_vs_precise() {
        // 测试几个关键点
        let test_values = vec![
            -693147180559945309i128,  // ln(0.5)
            0i128,                     // 0
            405465108108164000i128,    // ln(1.5)
            693147180559945000i128,    // ln(2.0)
        ];
        
        for &val in &test_values {
            let input = I256::from(val);
            let fast_result = LogExpMath2::exp_fast(input).unwrap();
            let precise_result = LogExpMath::exp(input).unwrap();
            
            let diff = if fast_result > precise_result {
                fast_result - precise_result
            } else {
                precise_result - fast_result
            };
            
            // 允许0.2%误差（exp的误差会稍大一些）
            let threshold = precise_result / I256::from(500u64);
            assert!(diff <= threshold,
                "exp({}) 误差过大: fast={}, precise={}, diff={}", 
                val, fast_result.as_u64(), precise_result.as_u64(), diff.as_u64());
            
            println!("exp({}) - fast: {}, precise: {}, diff: {}", 
                val, fast_result.as_u64(), precise_result.as_u64(), diff.as_u64());
        }
    }
}

